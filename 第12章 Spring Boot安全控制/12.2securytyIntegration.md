## 12.2 集成Spring Securyty

在Spring Boot中集成Spring Securyty一如既往的使用了启动器依赖，在创建Spring Starter项目时选中“Spring Securyty”依赖即可。

![image-20191230214146351](images/image-20191230214146351.png)

### 12.2.1 基本集成

添加“Spring Securyty”启动器依赖后，即完成了Spring Securyty，项目的pom文件中的依赖为：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
```

在项目中中添加一个控制器HelloController类，测试Spring Securyty是否正确工作。

```java
package com.example.security.controller;

import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/security/")
public class HelloController {
	
	@RequestMapping("/hello")
	public String hello() {
		return "Hello, Security.";
	}

}
```

运行应用后，打开浏览器，访问[http://localhost:8080/security/hello](http://localhost:8080/security/hello)，弹出Spring Securyty提供的默认认证页面，用户名为user，密码是在启动应用时生成的一个随机字符串（STS控制台中的密码信息：Using generated security password: 0585d7e0-dde1-4b9e-8352-27eb72517803）。

![image-20191231122309664](images/image-20191231122309664.png)

默认密码在应用启动时，打印在控制台中，当然每次启动时生成的密码都不一样。

![image-20191231122746947](images/image-20191231122746947.png)

使用user用户和生成的密码（这里是“0585d7e0-dde1-4b9e-8352-27eb72517803”）登录后，可正确访问HelloController返回的信息。

![image-20191231122454366](images/image-20191231122454366.png)

通过查看Spring Security的源码`org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration`类，可以看到inMemoryUserDetailsManager方法中使用的`SecurityProperties.User user`属性提供了用户名和密码。

```java
public InMemoryUserDetailsManager inMemoryUserDetailsManager(SecurityProperties properties,
                                                             ObjectProvider<PasswordEncoder> passwordEncoder) {
    SecurityProperties.User user = properties.getUser();
    List<String> roles = user.getRoles();
    return new InMemoryUserDetailsManager(
        User.withUsername(user.getName()).password(getOrDeducePassword(user, passwordEncoder.getIfAvailable()))
        .roles(StringUtils.toStringArray(roles)).build());
}
```

进一步查看这个User类，可以看到默认登录用户为user，密码为一个uuid字符串。

```java
public static class User {

    /**
		 * Default user name.
		 */
    private String name = "user";

    /**
		 * Password for the default user name.
		 */
    private String password = UUID.randomUUID().toString();

    /**
		 * Granted roles for the default user name.
		 */
    private List<String> roles = new ArrayList<>();

    private boolean passwordGenerated = true;

    public String getName() {
        return this.name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getPassword() {
        return this.password;
    }

    public void setPassword(String password) {
        if (!StringUtils.hasLength(password)) {
            return;
        }
        this.passwordGenerated = false;
        this.password = password;
    }

    public List<String> getRoles() {
        return this.roles;
    }

    public void setRoles(List<String> roles) {
        this.roles = new ArrayList<>(roles);
    }

    public boolean isPasswordGenerated() {
        return this.passwordGenerated;
    }

}
```

如果我们简单的在application.properties文件中指定用户名和密码：

```properties
spring.security.user.name=kevin
spring.security.user.password=6998
spring.security.user.roles=admin
```

则应用在启动时，就不会生成随机的uuid密码，也不会在控制台中打印`Using generated security password: 0585d7e0-dde1-4b9e-8352-27eb72517803`这样的信息了。

这个时候，通过浏览器访问[http://localhost:8080/security/hello](http://localhost:8080/security/hello)则需要输入kevin用户和6998密码，就可以正常访问后台业务逻辑并返回正确的结果，并且该用户具有admin角色（虽然这个示例中角色没有任何用处）。

### 12.2.2 基于内存的认证

在本小节的学习过程中，通过将用户、密码和角色配置在内存中，会更方便集中精力学习Spring Securyty。

注释掉上一小节application.properties文件中指定的用户名、密码和角色。

> 后续小节我们会通过数据库来完成一个RBAC地安全控制示例。

```java
package com.example.security.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.crypto.password.NoOpPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;

@Configuration
@EnableWebSecurity
public class SecurityConfiguration extends WebSecurityConfigurerAdapter {
	@Bean
	PasswordEncoder passwordEncoder() {
		return NoOpPasswordEncoder.getInstance();
	}
	
	@Override
	protected void configure(AuthenticationManagerBuilder auth) throws Exception {
		auth.inMemoryAuthentication()
		.withUser("admin").password("admin").roles("ADMIN", "USER")
		.and()
		.withUser("kevin").password("6998").roles("USER")
		.and()
		.withUser("roy").password("3525").roles("USER");
	}
	
	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http.authorizeRequests()
		.antMatchers("/admin/**")
		.hasRole("ADMIN")
		.antMatchers("/user/**")
		.hasRole("USER")
		.anyRequest()
		.authenticated()
		.and()
		.formLogin()
		.loginProcessingUrl("/login")
		.permitAll();
	}
	
}
```

上述代码，首先注册一个PasswordEncoder（密码加密编码器类），这里为了测试简便，使用了不加密密码。在实际生产环境下绝对不能使用这个密码编码器类。

然后使用AuthenticationManagerBuilder.inMemoryAuthentication的内存认证，通过编码添加了3个用户和对应的角色（"ADMIN", "USER"）。

最后使用HttpSecurity为不同的资源匹配了不同的角色访问权限。

添加AdminController控制器类，提供“/admin/hello”资源。

```java
package com.example.security.controller;

import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/admin/")
public class AdminController {
	
	@RequestMapping("/hello")
	public String hello() {
		return "admin.hello";
	}

}
```

添加UserController控制器类，提供“/user/hello”资源。

```java
package com.example.security.controller;

import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/user/")
public class UserController {

	@RequestMapping("/hello")
	public String hello() {
		return "user.hello";
	}

}
```

启动应用，测试：

- 使用admin用户登录，可以正确访问“/admin/hello”和“/user/hello”资源。

- 使用kevin用户登录，可以正确访问“/user/hello”资源，不能正确访问“/admin/hello”资源，错误信息如下：

  ![image-20200101233505995](images/image-20200101233505995.png)

以上就是一个基于内存认证的最简单的RBAC（基于角色的存取控制）权限控制系统：

- kevin拥有USER角色；
- “/user/**”资源授权给USER角色；
- kevin登录后拥有USER角色，可以访问“/user/hello”资源。

### 12.2.3 登录表单/注销配置



### 12.2.4 密码加密



### 12.2.5 基于数据库的认证





