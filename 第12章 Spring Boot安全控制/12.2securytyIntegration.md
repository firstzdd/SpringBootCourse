## 12.2 集成Spring Securyty

在Spring Boot中集成Spring Securyty一如既往地使用了启动器依赖，在创建Spring Starter项目时选中“Spring Securyty”依赖即可。

![image-20191230214146351](images/image-20191230214146351.png)

### 12.2.1 基本集成

添加“Spring Securyty”启动器依赖后，即完成了Spring Securyty，项目的pom文件中的依赖为：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
```

在项目中添加一个控制器HelloController类，测试Spring Securyty是否正确工作。

```java
package com.example.security.controller;

import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/security/")
public class HelloController {
	
	@RequestMapping("/hello")
	public String hello() {
		return "Hello, Security.";
	}

}
```

运行应用后，打开浏览器，访问[http://localhost:8080/security/hello](http://localhost:8080/security/hello)，弹出Spring Securyty提供的默认认证页面，用户名为user，密码是在启动应用时生成的一个随机字符串（STS控制台中的密码信息：Using generated security password: 0585d7e0-dde1-4b9e-8352-27eb72517803）。

![image-20191231122309664](images/image-20191231122309664.png)

默认密码在应用启动时，打印在控制台中，当然每次启动时生成的密码都不一样。

![image-20191231122746947](images/image-20191231122746947.png)

使用user用户名和生成的密码（这里是“0585d7e0-dde1-4b9e-8352-27eb72517803”）登录后，可正确访问HelloController返回的信息。

![image-20191231122454366](images/image-20191231122454366.png)

通过查看Spring Security的源码`org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration`类，可以看到inMemoryUserDetailsManager方法中使用的`SecurityProperties.User user`属性提供了用户名和密码。由getOrDeducePassword方法通过日志`logger.info(String.format("%n%nUsing generated security password: %s%n", user.getPassword()));`将生成的默认密码打印到控制台。

```java
public InMemoryUserDetailsManager inMemoryUserDetailsManager(SecurityProperties properties,
                                                             ObjectProvider<PasswordEncoder> passwordEncoder) {
    SecurityProperties.User user = properties.getUser();
    List<String> roles = user.getRoles();
    return new InMemoryUserDetailsManager(
        User.withUsername(user.getName()).password(getOrDeducePassword(user, passwordEncoder.getIfAvailable()))
        .roles(StringUtils.toStringArray(roles)).build());
}
```

进一步查看这个User类，可以看到默认登录用户为user，密码为一个uuid字符串。

```java
public static class User {

    /**
		 * Default user name.
		 */
    private String name = "user";

    /**
		 * Password for the default user name.
		 */
    private String password = UUID.randomUUID().toString();

    /**
		 * Granted roles for the default user name.
		 */
    private List<String> roles = new ArrayList<>();

    private boolean passwordGenerated = true;

    public String getName() {
        return this.name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getPassword() {
        return this.password;
    }

    public void setPassword(String password) {
        if (!StringUtils.hasLength(password)) {
            return;
        }
        this.passwordGenerated = false;
        this.password = password;
    }

    public List<String> getRoles() {
        return this.roles;
    }

    public void setRoles(List<String> roles) {
        this.roles = new ArrayList<>(roles);
    }

    public boolean isPasswordGenerated() {
        return this.passwordGenerated;
    }

}
```

如果我们简单的在application.properties文件中指定用户名和密码：

```properties
spring.security.user.name=kevin
spring.security.user.password=6998
spring.security.user.roles=admin
```

则应用在启动时，就不会生成随机的uuid密码，也不会在控制台中打印`Using generated security password: 0585d7e0-dde1-4b9e-8352-27eb72517803`这样的信息了。

这个时候，通过浏览器访问[http://localhost:8080/security/hello](http://localhost:8080/security/hello)则需要输入kevin用户和6998密码，就可以正常访问后台业务逻辑并返回正确的结果，并且该用户具有admin角色（虽然这个示例中角色没有任何用处）。

### 12.2.2 密码加密

除了在学习环境下，为了安全起见，密码存储都**必须要加密**。

Spring Securyty通过实现PasswordEncoder接口，提供了众多的密码加密类（包括供我们在学习环境下使用的NoOpPasswordEncoder明文密码编码器），供我们在实际工作中根据需要选用。

![image-20200102104426724](images/image-20200102104426724.png)

> 奇葩的NoOpPasswordEncoder类：encode(CharSequence rawPassword) 方法的返回值为encode(CharSequence rawPassword) ，也就是密码编码返回明文，所以千万不要在生产环境中使用。

修改SecurityConfiguration类，添加BCryptPasswordEncoder密码编码器。

> BCryptPasswordEncoder，使用了BCrypt强哈希方法来加密密码。

```java
package com.example.security.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;

@Configuration
@EnableWebSecurity
public class SecurityConfiguration extends WebSecurityConfigurerAdapter {
	@Bean
	PasswordEncoder passwordEncoder() {
		PasswordEncoder encoder = new BCryptPasswordEncoder();
		return encoder;
	}
	
	@Override
	protected void configure(AuthenticationManagerBuilder auth) throws Exception {
		auth.inMemoryAuthentication()
		.withUser("admin").password(new BCryptPasswordEncoder().encode("admin")).roles("ADMIN", "USER")
		.and()
		.withUser("kevin").password(new BCryptPasswordEncoder().encode("6998")).roles("USER")
		.and()
		.withUser("roy").password(new BCryptPasswordEncoder().encode("3525")).roles("USER");
	}
	
	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http.authorizeRequests()
		.antMatchers("/admin/**")
		.hasRole("ADMIN")
		.antMatchers("/user/**")
		.hasRole("USER")
		.anyRequest()
		.authenticated()
		.and()
		.formLogin()
		.loginProcessingUrl("/login")
		.permitAll();
	}
	
}
```

上面的示例中PasswordEncoder使用了BCryptPasswordEncoder实现类，并且在基于内存的认证器中给出用户密码时，使用了BCryptPasswordEncoder加密密码（password(new BCryptPasswordEncoder().encode("admin"))）。这样，内存中存储的密码时通过BCrypt加密的密码，用户在登录页面输入密码（例如admin用户的密码admin）后，Spring Securyty使用PasswordEncoder对密码进行编码后与内存中存储的加密后的密码对比，完成认证，正确后就放行。

### 12.2.3 基于内存的认证

在本小节的学习过程中，通过将用户、密码和角色配置在内存中，会更方便集中精力学习Spring Securyty。

注释掉上一小节application.properties文件中指定的用户名、密码和角色。

> 后续小节我们会通过数据库来完成一个RBAC的安全控制示例。

```java
package com.example.security.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.crypto.password.NoOpPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;

@Configuration
@EnableWebSecurity
public class SecurityConfiguration extends WebSecurityConfigurerAdapter {
	@Bean
	PasswordEncoder passwordEncoder() {
		return NoOpPasswordEncoder.getInstance();
	}
	
	@Override
	protected void configure(AuthenticationManagerBuilder auth) throws Exception {
		auth.inMemoryAuthentication()
			.withUser("admin").password("admin").roles("ADMIN", "USER")
		.and()
			.withUser("kevin").password("6998").roles("USER")
		.and()
			.withUser("roy").password("3525").roles("USER");
	}
	
	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http.authorizeRequests()
            .antMatchers("/admin/**")
            .hasRole("ADMIN")
            .antMatchers("/user/**")
            .hasRole("USER")
            .anyRequest()
            .authenticated()
		.and()
            .formLogin()
            .loginProcessingUrl("/login")
            .permitAll();
	}
	
}
```

上述代码，首先注册一个PasswordEncoder（密码加密编码器类），这里为了测试简便，使用了不加密密码。在实际生产环境下**绝对不能使用**这个密码编码器类。

然后使用AuthenticationManagerBuilder.inMemoryAuthentication的内存认证，通过编码添加了3个用户和对应的角色（"ADMIN", "USER"）。

最后使用HttpSecurity为不同的资源匹配了不同的角色访问权限。

添加AdminController控制器类，提供“/admin/hello”资源。

```java
package com.example.security.controller;

import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/admin/")
public class AdminController {
	
	@RequestMapping("/hello")
	public String hello() {
		return "admin.hello";
	}

}
```

添加UserController控制器类，提供“/user/hello”资源。

```java
package com.example.security.controller;

import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/user/")
public class UserController {

	@RequestMapping("/hello")
	public String hello() {
		return "user.hello";
	}

}
```

启动应用，测试：

- 使用admin用户登录，可以正确访问“/admin/hello”和“/user/hello”资源。

- 使用kevin用户登录，可以正确访问“/user/hello”资源，不能正确访问“/admin/hello”资源，错误信息如下：

  ![image-20200101233505995](images/image-20200101233505995.png)

以上就是一个基于内存认证的最简单的RBAC（基于角色的存取控制）权限控制系统：

- kevin拥有USER角色；
- “/user/**”资源授权给USER角色；
- kevin登录后拥有USER角色，可以访问“/user/hello”资源。

### 12.2.4 登录表单/注销配置

虽然Spring Securyty提供了默认的登录表单，但是在实际工作中绝大多数情况都用不上。基本上在所有的项目/产品中，都会使用自定义的登录表单。当然，注销登录（或者叫做登出），也会使用自定义的配置。

通过查看Spring Securyty源码，可以看到默认登录表单在`org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter.generateLoginPageHtml`方法中构建。

在DefaultLoginPageGeneratingFilter类的doFilter方法中`response.getWriter().write(loginPageHtml)`代码向浏览器输出登录表单。

```java
public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
    throws IOException, ServletException {
    HttpServletRequest request = (HttpServletRequest) req;
    HttpServletResponse response = (HttpServletResponse) res;

    boolean loginError = isErrorPage(request);
    boolean logoutSuccess = isLogoutSuccess(request);
    if (isLoginUrlRequest(request) || loginError || logoutSuccess) {
        String loginPageHtml = generateLoginPageHtml(request, loginError,
                                                     logoutSuccess);
        response.setContentType("text/html;charset=UTF-8");
        response.setContentLength(loginPageHtml.getBytes(StandardCharsets.UTF_8).length);
        response.getWriter().write(loginPageHtml);

        return;
    }

    chain.doFilter(request, response);
}
```

本小节，我们使用Thymeleaf模板+基于内存认证方式来学习如何自定义登录表单。

首先，我们添加几个简单的页面，然后通过Spring Securyty基于内存的配置设置其用户、角色、自定义登录表单、注销等操作。

#### 12.2.4.1 首页

创建`src/main/resources/templates/index.html`页面，作为项目的首页。

```html
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
<title>示例首页</title>
</head>
<body>
	<h1>示例首页</h1>
	<p>登录成功后，自动跳转到这里</p>
	<p>
		点击 <a th:href="@{/user/hello}">这里</a> 进入User Hello页面。
	</p>
	<p>
		点击 <a th:href="@{/admin/hello}">这里</a> 进入Admin Hello页面。
	</p>
	
	<form th:action="@{/logout}" method="post">
		<input type="submit" value="退出（登出，logout）" />
	</form>
</body>
</html>
```

#### 12.2.4.2 登录页面

创建`src/main/resources/templates/login.html`页面，作为项目的登录页面。

```html
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
<title>自定义登录示例</title>
</head>
<body>
	<h1>请你登录</h1>
	<div th:if="${param.error}">用户名或密码错</div>
	<div th:if="${param.logout}">您已注销成功</div>
	<form th:action="@{/login}" method="post">
		<div>
			<label> 用户名 : <input type="text" name="login_username" />
			</label>
		</div>
		<div>
			<label> 密码 : <input type="password" name="login_password" />
			</label>
		</div>
		<div>
			<input type="submit" value="登录" />
		</div>
	</form>
</body>
</html>
```

在登录页面中，特意将用户名input设为login_username，演示匹配后续的自定义登录页面配置信息。

#### 12.2.4.3 管理页面

创建`src/main/resources/templates/admin/hello.html`，作为项目的管理页面，按照本示例设置，需要ADMIN角色的用户才可以访问。

```
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
<title>Admin.Hello Page</title>
</head>
<body>
	<h1>Admin Page</h1>
	<p th:text="${user}"/>
	<p><a th:href="@{/index}">返回</a></p>
</body>
</html>
```

#### 12.2.4.4 用户页面

创建`src/main/resources/templates/user/hello.html`，作为项目的用户页面，按照本示例设置，需要USER角色的用户才可以访问。

```html
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
<title>User.Hello Page</title>
</head>
<body>
	<h1>User Page</h1>
	<p><p th:text="${user}"/></p>
	<p><a th:href="@{/index}">返回</a></p>
</body>
</html>
```

#### 12.2.4.5 页面Controller

新建一个控制页面跳转的PageController，将上述4个页面串接起来。

```java
package com.example.security.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.servlet.ModelAndView;

@Controller
public class PagesController {
	
	@RequestMapping("/index")
	public String index() {
		return "/index";
	}
	
	@RequestMapping(value = "/login", method = RequestMethod.GET)
	public String login() {
		return "/login";
	}
	
	@RequestMapping("/admin/hello")
	public ModelAndView adminHello() {
		ModelAndView mv = new ModelAndView();
		mv.addObject("user", "admin");
		mv.setViewName("/admin/hello");
		return mv;
	}

	@RequestMapping("/user/hello")
	public ModelAndView userHello() {
		ModelAndView mv = new ModelAndView();
		mv.addObject("user", "kevin");
		mv.setViewName("/user/hello");
		return mv;
	}
}
```

#### 12.2.4.6 Spring Securyty配置

在启用了Spring Securyty的Spring Boot应用中，我们可以通过自定义表单html页面，然后通过HttpSecurity的formLogin和logout自定义登录页面和注销（登出）操作和行为。

```java
package com.example.security.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.builders.WebSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;

@Configuration
@EnableWebSecurity
public class SecurityConfiguration extends WebSecurityConfigurerAdapter {
	
	@Override
	protected void configure(AuthenticationManagerBuilder auth) throws Exception {
		auth.inMemoryAuthentication()
		.passwordEncoder(new BCryptPasswordEncoder())
		.withUser("admin").password(new BCryptPasswordEncoder().encode("admin")).roles("ADMIN", "USER")
		.and()
		.withUser("kevin").password(new BCryptPasswordEncoder().encode("6998")).roles("USER")
		.and()
		.withUser("roy").password(new BCryptPasswordEncoder().encode("3525")).roles("USER");
	}
	
	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http.formLogin()
			.loginPage("/login")
			.usernameParameter("login_username")
			.passwordParameter("login_password")
			.failureUrl("/login?error")
			.defaultSuccessUrl("/index")
			.permitAll()
		.and().logout()
			.logoutUrl("/logout")
			.logoutSuccessUrl("/login?logout")
			.clearAuthentication(true)
			.invalidateHttpSession(true)
			.permitAll()
		.and().authorizeRequests()
			.antMatchers("/admin/**").hasRole("ADMIN")
			.antMatchers("/user/**").hasRole("USER")
			.antMatchers("/login.html", "/login", "/index.html", "/index").permitAll()
			.anyRequest()
			.authenticated();
	}
	
	@Override
    public void configure(WebSecurity web) {
		web.ignoring().antMatchers("/config/**", "/css/**", "/fonts/**", "/img/**", "/js/**");
    }
	
}
```

#### 12.2.4.7 测试

启动应用程序，打开浏览器，输出[http://localhost:8080/](http://localhost:8080/)地址，自动跳转到登录页面。

![image-20200104234551358](images/image-20200104234551358.png)

输入错误的用户名，会跳转回登录页面，并且显示错误信息：用户名或密码错。

![image-20200104235008590](images/image-20200104235008590.png)

输入正确的用户名和密码，登录后会跳转到首页。

![image-20200104235203435](images/image-20200104235203435.png)

点击User Hello页面的链接，可以正确访问User Hello页面。

![image-20200104235324026](images/image-20200104235324026.png)

返回首页，后点击Admin Hello页面的链接，由于Kevin用户不具有ADMIN角色，所以不可以访问Admin Hello页面。

![image-20200104235456419](images/image-20200104235456419.png)

以上测试，符合项目权限控制预期。

### 12.2.5 基于数据库的认证





