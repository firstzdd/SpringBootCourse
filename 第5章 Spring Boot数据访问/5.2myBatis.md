## 5.2 Spring Boot集成MyBatis

MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。

MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。 

> 官方[参考文档](https://mybatis.org/mybatis-3/zh/index.html)，有中文版，描述非常详细，在这里，能解决你的所有疑问。

由于MyBatis在系统复杂性、便捷性和可控性方面找到了一个较好平衡。能够满足DBA对数据库的架构设计，也能满足开发人员对复杂SQL的编写，同时又能满足技术经理/架构师对SQL调优的需求。所以，最近几年来，MyBatis使用得越来越广泛。

要想掌握MyBatis，必须熟悉其几个重要的概念：

1. **mapper：**映射器，里面存放了增删改查等映射语句和其对应的java接口（在运行时使用 动态代理），通常情况下，我们指一个mapper是在说这个mapper的xml文件和其对应的接口java文件。MyBatis 的真正强大在于它的映射语句，也是它的魔力所在。由于它的异常强大，映射器（mapper）的 XML 文件就显得相对简单。如果拿它跟具有相同功能的 JDBC 代码进行对比，你会立即发现省掉了将近 95% 的代码。MyBatis 就是针对 SQL 构建的，并且比普通的方法做的更好。 
2. **namespace：**命名空间。在之前版本的 MyBatis 中，命名空间的作用并不大，是可选的。 但现在，随着命名空间越发重要，你必须指定命名空间。命名空间的作用有两个。
- 利用更长的完全限定名来将不同的语句隔离开来，同时将mapper的xml文件和java接口绑定。
   - 将命名空间置于合适的 Java 包命名空间之中，代码会变得更加整洁，也有利于你更方便地使用 MyBatis。
3. **resultType：**返回结果类型。例如如一个按照id查询的select语句返回表中一条记录，MyBatis通过mapper，在java中将其映射成一个对象返回。

MyBatis中的概念较多，对应使用到的文件也较多，为了更加形象的理解MyBatis的配置对应关系，我们通过如下的MyBatis配置关系示意图，来学习如何正确地将MyBatis的各种元素有机的联系起来。

![image-20191114161351760](images/image-20191114161351760.png)

如上图所示：

1. 红色mapper 2.1指定了mapper映射xml文件（例如上图中的2.1* UserMapper.xml文件，其中存放了select等语句）存放的位置；
2. 红色namespace命名空间 2.2将本mapper映射xml文件和对应的java接口文件（2.2*）连接起来；
3. 

Spring Boot通过starter使用MyBatis是非常方便的。

在pom.xml文件中添加`mybatis-spring-boot-starter`启动器，和MySQL数据的jdbc驱动，就可以使用MyBatis了。

```xml
<dependency>
    <groupId>org.mybatis.spring.boot</groupId>
    <artifactId>mybatis-spring-boot-starter</artifactId>
    <version>2.1.1</version>
</dependency>
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <scope>runtime</scope>
</dependency>
```

> 需要注意的是：在我们的练习环境中使用的是MySQL 5.7数据库，Spring Boot使用当前的jdbc驱动（8.0.18）application.yml配置需要注意如下两点：
>
> - url需要设置时区参数，例如`jdbc:mysql://localhost:3306/spring_boot_course?useUnicode=true&characterEncoding=utf-8&serverTimezone=GMT%2B8`；
> - jdbc驱动，需要使用`com.mysql.cj.jdbc.Driver`。





### 5.2.1 创建项目

首先在STS中创建一个Spring Boot项目，选中的starter有：

- Spring Web;
- MySQL Driver;
- MyBatis Framework.

![image-20191113225746013](images/image-20191113225746013.png)







 https://www.cnblogs.com/lixuwu/p/5900951.html 



mapper.xml文件中resultMap的type或者parameterType会使用自定义的pojo，

此时可以用完全限定名来指定这些POJO的引用，例如

```xml
<select id="getUsers" resultType="com.e3mall.cms.dao.mapper.User">
```

又或者你可以通过在application.properties中指定POJO扫描包来让mybatis自动扫描到自定义POJO，如下：

mybatis.type-aliases-package=com.e3mall.cms.dao.mapper



```yaml
# PageHelper 分页插件配置
pagehelper:
  helper-dialect: mysql
  reasonable: true
  support-methods-arguments: true
  params: count=countsql
# mysql数据源配置
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/spring_boot_course?useUnicode=true&characterEncoding=utf-8&serverTimezone=GMT%2B8
    username: root
    password: 123456
    driver-class-name: com.mysql.cj.jdbc.Driver
# mybatis 配置信息
mybatis:
  mapper-locations: classpath:mapping/*Mapper.xml
  type-aliases-package: com.example.mybatis.entity
```





namespace属性

在MyBatis中，Mapper中的namespace用于绑定Dao接口的，即面向接口编程。

它的好处在于当使用了namespace之后就可以不用写接口实现类，业务逻辑会直接通过这个绑定寻找到相对应的SQL语句进行对应的数据处理







![image-20191114105653938](images/image-20191114105653938.png)



# **mapper.xml中常用的标签详解**

## 一、**SQL语句标签：**

1. <!--查询语句--> 
2. ** id="selectByPrimaryKey" resultMap="BaseResultMap" parameterType="java.lang.String" **>** 
3. select  
4. ****
5. 
6. <!--插入语句--> 
7. ** id="insert" parameterType="pojo.OrderTable" **>** 
8. insert into ordertable (order_id, cid, address,  
9. create_date, orderitem_id) 
10. values (#{orderId,jdbcType=VARCHAR}, #{cid,jdbcType=VARCHAR}, #{address,jdbcType=VARCHAR},  
11. \#{createDate,jdbcType=TIMESTAMP}, #{orderitemId,jdbcType=VARCHAR}) 
12. ****
13. 
14. <!--删除语句--> 
15. ** id="deleteByPrimaryKey" parameterType="java.lang.String" **>** 
16. delete from ordertable 
17. where order_id = #{orderId,jdbcType=VARCHAR} 
18. ****
19. 
20. <!--修改语句--> 
21. ** id="updateByPrimaryKey" parameterType="pojo.OrderTable" **>** 
22. update ordertable 
23. set cid = #{cid,jdbcType=VARCHAR}, 
24. address = #{address,jdbcType=VARCHAR}, 
25. create_date = #{createDate,jdbcType=TIMESTAMP}, 
26. orderitem_id = #{orderitemId,jdbcType=VARCHAR} 
27. where order_id = #{orderId,jdbcType=VARCHAR} 
28. ****

需要配置的属性：id="xxxx" >>> 表示此段sql执行语句的唯一标识，也是接口的方法名称【必须一致才能找到】

parameterType="" >>>表示该sql语句中需要传入的参数， 类型要与对应的接口方法的类型一致【可选】

resultMap=“ ”>>> 定义出参，调用已定义的<resultMap>映射管理器的id值

resultType=“ ”>>>定义出参，匹配普通java类型或自定义的pojo【出参类型若不指定，将为语句类型默认类型，如<insert>语句返回值为int】

p.s： 至于为何<insert><delete><update> 语句的返回值类型为什么是int，有过JDBC操作经验的朋友可能会有印象，增删改操作实际上返回的是操作的条数。而Mybatis框架本身是基于JDBC的，所以此处也沿袭这种返回值类型。

传参和取值：mapper.xml 的灵活性还体现在SQL执行语句可以传参，参数类型通过parameterType= “” 定义

取值方式1：#{value jdbcType = valuetype}：jdbcType 表示该属性的数据类型在数据库中对应的类型，如 #{user jdbcType=varchar} 等价于 String username；

取值方式2：${value } : **这种方式不建议大量使用**，可能会发送sql注入而导致安全性问题。一般该取值方式可用在非经常变化的值上，如orderby ${columnName}；

## **二、****sql片段标签**

通过该标签可定义能复用的sql语句片段，在执行sql语句标签中直接引用即可。这样既可以提高编码效率，还能有效简化代码，提高可读性

   需要配置的属性：id="" >>>表示需要改sql语句片段的唯一标识

   引用：通过<include refid="" />标签引用，refid="" 中的值指向需要引用的<sql>中的id=“”属性

1. <!--定义sql片段--> 
2. ** id="orderAndItem"**>** 
3. o.order_id,o.cid,o.address,o.create_date,o.orderitem_id,i.orderitem_id,i.product_id,i.count 
4. ****
5. 
6. ** id="findOrderAndItemsByOid" parameterType="java.lang.String" resultMap="BaseResultMap"**>** 
7. select 
8. <!--引用sql片段--> 
9. ** refid="orderAndItem" **/>** 
10. from ordertable o 
11. join orderitem i on o.orderitem_id = i.orderitem_id 
12. where o.order_id = #{orderId} 
13. ****

## 三、**映射管理器resultMap**

映射管理器，是Mybatis中最强大的工具，使用其可以进行实体类之间的关系，并管理结果和实体类间的映射关系

   需要配置的属性：<resultMap id="  " type="  "></resutlMap>  id=" ">>>表示这个映射管理器的唯一标识，外部通过该值引用； type = " ">>> 表示需要映射的实体类；

   需要配置的参数：<id column = " " property= " " />   <id>标签指的是：结果集中结果唯一的列【column】 和 实体属性【property】的映射关系，注意：<id>标签管理的列未必是主键列，需要根据具体需求指定；

  <result column= " " property=" " />  <result>标签指的是：结果集中普通列【column】 和 实体属性【property】的映射关系；

​      需要维护的关系：所谓关系维护是值在主表查询时将其关联子表的结果也查询出来

  1）一对一关系<assocation property = " " javaType=" ">  property = “ ” 被维护实体在宿主实体中的属性名，javaType = " " 被维护实体的类型

Orderitem.java

1. **package** pojo; 
2. 
3. **public** **class** Orderitem { 
4. 
5. **private** String orderitemId; 
6. 
7. **private** String productId; 
8. 
9. **private** Integer count; 
10. 
11. **private** Product product;   

从上方代码段可以看出：Product 对象在 Orderitem 实体中以 product 属性存在 

Orderitemmapper.xml

1. **<****resultMap** id="BaseResultMap" type="pojo.Orderitem" **>** 
2. ** column="orderitem_id" property="orderitemId" jdbcType="VARCHAR" **/>** 
3. ** column="product_id" property="productId" jdbcType="VARCHAR" **/>** 
4. ** column="count" property="count" jdbcType="INTEGER" **/>** 
5. <!-- 通过association 维护 一对一关系 --> 
6. ** property="product" javaType="pojo.Product"**>** 
7. ** column="product_id" property="productId"**/>** 
8. ** column="product_factroy" property="productFactroy"**/>** 
9. ** column="product_store" property="productStore"**/>** 
10. ** column="product_descript" property="productDescript"**/>** 
11. ****
12. ****

通过xml的配置可以看出，在resultMap映射管理器中，通过<association> 进行了维护，也就是在查询Orderitem对象时，可以把关联的Product对象的信息也查询出来

2）一对多关系的维护<collection property=" " ofType=" "> property = “ ” 被维护实体在宿主实体中的属性名 ，ofType=“ ”是被维护方在宿主类中集合泛型限定类型

【由于在一对多关系中，多的一放是以List形式存在，因此ofType的值取用Lsit<?> 的泛型对象类型】

OrderTable.java

1. **public** **class** OrderTable { 
2. 
3. **private** String orderId; 
4. 
5. **private** String cid; 
6. 
7. **private** String address; 
8. 
9. **private** Date createDate; 
10. 
11. **private** String orderitemId;
12. 
13. **private** List<Orderitem> orderitemList ; 
14. }

 

OrderTableMapper.xml; 

1. **<****resultMap** id="BaseResultMap" type="pojo.OrderTable" **>** 
2. <!-- 
3. WARNING - @mbggenerated 
4. This element is automatically generated by MyBatis Generator, do not modify. 
5. This element was generated on Fri May 06 15:49:42 CST 2016. 
6. --**>** 
7. ** column="order_id" property="orderId" jdbcType="VARCHAR" **/>** 
8. ** column="cid" property="cid" jdbcType="VARCHAR" **/>** 
9. ** column="address" property="address" jdbcType="VARCHAR" **/>** 
10. ** column="create_date" property="createDate" jdbcType="TIMESTAMP" **/>** 
11. ** column="orderitem_id" property="orderitemId" jdbcType="VARCHAR" **/>** 
12. <!--维护一对多的关系 --> 
13. ** property="orderitemList" ofType="pojo.Orderitem"**>** 
14. ** column="orderitem_id" property="orderitemId"**/>** 
15. ** column="product_id" property="productId"**/>** 
16. ** column="count" property="count"**/>** 
17. ****
18. ****

 

3）在resultMap 中需要注意两点：

3.1）关联关系的维护可以根据实体类之间的实际情况进行嵌套维护

3.2）关于出现重复列名的处理：在实际操作过程中，查询到的结果可能会出现相同的列名，这样会对映射到实体属性带来影响甚至出现报错，那么对待这个问题可以通过对列取别名的方式处理

 

## **四：常用的动态语句标签**

通过动态sql标签可以进行条件判断，条件遍历等操作从而满足结果的需要

 <where> ： 使用其可以代替sql语句中的where关键字，一般防止在条件查询的最外层

​     <if >：条件判断标签，配置属性test=" 条件字符串 "，判断是否满足条件，满足则执行，不满足则跳过

1. **<****select** id="findOrderItemDetail" parameterType="pojo.Orderitem" resultMap="BaseResultMap"**>** 
2. select orderitem.orderitem_id,product.*  
3. from orderitem,product 
4. ****
5. ** test="orderitemId!=null and orderitemId!=''"**>** 
6. and orderitem.orderitem_id = #{orderitemId} 
7. ****
8. ** test="productId!=null and productId!=''"**>** 
9. and orderitem.product_id = #{productId} 
10. ****
11. ** test="count!=null"**>** 
12. and orderitem.count = #{count} 
13. ****
14. ****
15. ****

<set>：常用于<update>更新语句中，替代 sql中的“set”关键字，特别是在联合<if>进行判断是，可以有效方式当某个参数为空或者不合法是错误的更新到数据库中

1. **<****update** id="updateByPrimaryKeySelective" parameterType="pojo.Orderitem" **>** 
2. update orderitem 
3. ** **>** 
4. ** test="productId != null" **>** 
5. product_id = #{productId,jdbcType=VARCHAR}, 
6. ****
7. ** test="count != null" **>** 
8. count = #{count,jdbcType=INTEGER}, 
9. ****
10. ****
11. where orderitem_id = #{orderitemId,jdbcType=VARCHAR} 
12. ****

<choose><when></when><otherwise></otherwise></choose> 标签组：也是一个用于条件判断的标签组，和<if>的不同之处在于条件从<choose>进入，去匹配<when>中的添加，一旦匹配马上结束；若到找不到匹配项，将执行<other>中的语句；可以理解为<if>是 && 关系 <choose>是 || 关系

1. <!-- 查询学生list，like姓名、或=性别、或=生日、或=班级，使用choose -->    
2. ** id="getStudentListChooseEntity" parameterType="StudentEntity" resultMap="studentResultMap"**>**    
3. SELECT * from STUDENT_TBL ST    
4. ****
5. ****
6. ** test="studentName!=null and studentName!='' "**>**    
7. ST.STUDENT_NAME LIKE CONCAT(CONCAT('%', #{studentName}),'%')    
8. ****
9. ** test="studentSex!= null and studentSex!= '' "**>**    
10. AND ST.STUDENT_SEX = #{studentSex}    
11. ****
12. ** test="studentBirthday!=null"**>**    
13. AND ST.STUDENT_BIRTHDAY = #{studentBirthday}    
14. ****
15. ** test="classEntity!=null and classEntity.classID !=null and classEntity.classID!='' "**>**    
16. AND ST.CLASS_ID = #{classEntity.classID}    
17. ****
18. ****
19. 
20. ****
21. ****
22. ****
23. ****

<foreach>标签：该标签的作用是遍历集合类型的条件 

 属性：collection=“array” / collection = “list”  ----->是数组类型，还是集合类型

​       item=“ productId ”------> 参数名

   open="(" separator="," close=")"  ------>开始符号，分隔符号，结束符号 

   index=“ ” ---->结束下标位置，不配置该参数时，默认为全部遍历

1. **<****delete** id="deleteByPriKeys" parameterType="java.lang.String"**>** 
2. delete from product where product_Id in 
3. ** collection="list" item="productId" open="(" separator="," close=")"**>** 
4. \#{productId,jdbcType = VARCHAR} 
5. ****
6. ****