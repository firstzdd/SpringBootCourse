## 14.4 数据校验

在我们的日常工作中，对于任何一个应用而言，数据绝大多数情况下都会从客户端（前端，如浏览器）与服务端（后端，如tomcat）之间来回传输，如果只做客户端数据校验是远远不够的，是不安全的。我们必须在后台对数据进行验证，然后才将其持久化存储（如新增或更新到数据库）。

数据校验是一个企业级项目架构上最为基础的功能模块。

### 14.4.1 概念

[JSR-303 Bean Validation](https://jcp.org/en/jsr/detail?id=303) 是一个运行时的数据验证规范，为 JavaBean 验证定义了相应的元数据模型和 API。缺省的元数据是 Java Annotations，通过使用 XML 可以对原有的元数据信息进行覆盖和扩展。在应用程序中，通过使用 Bean Validation 或是你自己定义的 constraint，例如 `@NotNull`, `@Max`, `@ZipCode`， 就可以确保数据模型（JavaBean）的正确性。constraint 可以附加到字段，getter 方法，类或者接口上面。对于一些特定的需求，用户可以很容易的开发定制化的 constraint。Bean Validation 是一个运行时的数据验证框架，在验证之后验证的错误信息会被马上返回。

[Hibernate Validator](http://hibernate.org/validator/) 是 Bean Validation 的参考实现。 Hibernate Validator 提供了 JSR 303 规范中所有内置 constraint 的实现，除此之外还有一些附加的 constraint。

Spring's JSR-303规范，是标准JSR-303的一个变种。Spring Validation验证框架对参数的验证机制提供了@Validated，javax提供了@Valid（标准JSR-303规范），配合BindingResult可以直接提供参数验证结果。

常用的数据校验注解如下表：

| 限制                      | 说明                                                         |
| :------------------------ | :----------------------------------------------------------- |
| @Null                     | 限制只能为null                                               |
| @NotNull                  | 限制必须不为null                                             |
| @AssertFalse              | 限制必须为false                                              |
| @AssertTrue               | 限制必须为true                                               |
| @DecimalMax(value)        | 限制必须为一个不大于指定值的数字                             |
| @DecimalMin(value)        | 限制必须为一个不小于指定值的数字                             |
| @Digits(integer,fraction) | 限制必须为一个小数，且整数部分的位数不能超过integer，小数部分的位数不能超过fraction |
| @Future                   | 限制必须是一个将来的日期                                     |
| @Max(value)               | 限制必须为一个不大于指定值的数字                             |
| @Min(value)               | 限制必须为一个不小于指定值的数字                             |
| @Past                     | 限制必须是一个过去的日期                                     |
| @Pattern(value)           | 限制必须符合指定的正则表达式                                 |
| @Size(max,min)            | 限制字符长度必须在min到max之间                               |
| @Past                     | 验证注解的元素值（日期类型）比当前时间早                     |
| @NotEmpty                 | 验证注解的元素值不为null且不为空（字符串长度不为0、集合大小不为0） |
| @NotBlank                 | 验证注解的元素值不为空（不为null、去除首位空格后长度为0），不同于@NotEmpty，@NotBlank只应用于字符串且在比较时会去除字符串的空格 |
| @Email                    | 验证注解的元素值是Email，也可以通过正则表达式和flag指定自定义的email格式 |

### 14.4.2 原理

请参考 Spring 校验处理器org.springframework.validation.beanvalidation.BeanValidationPostProcessor类的源码。

BeanValidationPostProcessor 类内部有个boolean类型的属性afterInitialization，默认是false，如果是false，在postProcessBeforeInitialization过程中对bean进行验证，否则在postProcessAfterInitialization过程对bean进行验证。

```java
@Nullable
private Validator validator;

private boolean afterInitialization = false;

public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
    if (!this.afterInitialization) {
        doValidate(bean);
    }
    return bean;
}

public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
    if (this.afterInitialization) {
        doValidate(bean);
    }
    return bean;
}
```

真正处理校验的方法是doValidate方法，缺省使用ValidatorFactory的默认Validator（校验器）。

在Spring Boot中，默认校验器框架是HibernateValidator，所以 Spring 默认调用`org.hibernate.validator.internal.engine.ValidatorFactoryImpl`来生成validator供Spring Boot校验使用。

```java
protected void doValidate(Object bean) {
    Assert.state(this.validator != null, "No Validator set");
    Object objectToValidate = AopProxyUtils.getSingletonTarget(bean);
    if (objectToValidate == null) {
        objectToValidate = bean;
    }
    Set<ConstraintViolation<Object>> result = this.validator.validate(objectToValidate);

    if (!result.isEmpty()) {
        StringBuilder sb = new StringBuilder("Bean state is invalid: ");
        for (Iterator<ConstraintViolation<Object>> it = result.iterator(); it.hasNext();) {
            ConstraintViolation<Object> violation = it.next();
            sb.append(violation.getPropertyPath()).append(" - ").append(violation.getMessage());
            if (it.hasNext()) {
                sb.append("; ");
            }
        }
        throw new BeanInitializationException(sb.toString());
    }
}
```

在Spring Boot中添加spring-boot-starter-validation后，支持方法级别的JSR-303规范：

1. Spring Boot 自动配置（`org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration`）添加`org.springframework.validation.beanvalidation.MethodValidationPostProcessor`到Spring 容器中；
2. 类上加上@Validated注解；
3. 在方法的参数中加上验证注解，比如@Max、@Min、@NotEmpty、@NotNull等。

```java
package com.example.validation.demo;

import javax.validation.constraints.Min;
import javax.validation.constraints.NotEmpty;

import org.springframework.stereotype.Component;
import org.springframework.validation.annotation.Validated;

@Component
@Validated
public class DemoBeanForMethodValidation {
	public void validate(@NotEmpty String name, @Min(10) int age) {
		System.out.println("validate, name: " + name + ", age: " + age);
	}
}
```

这样，运行时，Spring就会调用校验器对数据进行校验。

### 14.4.3 集成

创建一个Spring Boot应用。

![image-20200124185755663](images/image-20200124185755663.png)

添加Spring Web启动器依赖。

![image-20200124185944969](images/image-20200124185944969.png)

在项目的pom中查看maven依赖，可以看到数据校验依赖（`spring-boot-starter-validation`）是直接包含在`spring-boot-starter-web`里面的，并且使用了`hibernate-validator`，所以我们在web应用中可以直接使用JSR-303规范的数据校验功能。

![image-20200124200000046](images/image-20200124200000046.png)

